pipeline {
    agent any
    
    triggers {
        pollSCM('H/2 * * * *')
    }
    
    environment {
        PYTHONPATH = "${WORKSPACE}/src"
        DOCKER_IMAGE = 'ace-est-fitness-and-gym'
        DOCKER_TAG = "${BUILD_NUMBER}"
        GCP_PROJECT_ID = 'itd-2021mt93693'
        GCP_REGION = 'us-central1'
        ARTIFACT_REGISTRY_REPO = 'ace-fitness-repo'
        K8S_NAMESPACE = 'ace-fitness'
        GKE_CLUSTER_NAME = 'ace-fitness-cluster'
        GCP_SERVICE_ACCOUNT_KEY = credentials('gcp-service-account-key')
        PYTHONDONTWRITEBYTECODE = '1'
        PYTHONUNBUFFERED = '1'
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Setup Python Environment') {
            agent {
                docker {
                    image 'python:3.11-slim'
                    reuseNode true
                }
            }
            steps {
                sh '''
                    python3 -m pip install --upgrade pip
                    pip install -r requirements.txt
                '''
            }
        }
        
        stage('Code Quality Check') {
            agent {
                docker {
                    image 'python:3.11-slim'
                    reuseNode true
                }
            }
            steps {
                sh '''
                    echo "Running code quality checks..."
                    pip install flake8
                    flake8 src/ --max-line-length=120 --exclude=__pycache__ || true
                '''
            }
        }
        
        stage('Unit Tests') {
            agent {
                docker {
                    image 'python:3.11-slim'
                    reuseNode true
                }
            }
            steps {
                sh '''
                    echo "Running unit tests..."
                    pip install pytest pytest-cov
                    python -m pytest tests/ -v --tb=short --cov=src --cov-report=xml --cov-report=html || true
                '''
            }
            post {
                always {
                    junit testResults: '**/test-*.xml', allowEmptyResults: true
                    publishCoverage adapters: [coberturaAdapter('coverage.xml')], sourceFileResolver: sourceFiles('STORE_ALL_BUILD')
                }
            }
        }
        
        stage('Build Version') {
            steps {
                script {
                    env.VERSION = readFile('build.version').trim()
                    env.FULL_IMAGE_NAME = "${GCP_REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/${ARTIFACT_REGISTRY_REPO}/${DOCKER_IMAGE}:${VERSION}-${BUILD_NUMBER}"
                    env.LATEST_IMAGE_NAME = "${GCP_REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/${ARTIFACT_REGISTRY_REPO}/${DOCKER_IMAGE}:latest"
                    echo "Building version: ${env.VERSION}"
                    echo "Full image name: ${env.FULL_IMAGE_NAME}"
                }
            }
        }
        
        stage('Build Docker Image with Kaniko') {
            agent {
                docker {
                    image 'gcr.io/kaniko-project/executor:debug'
                    args '--entrypoint=""'
                    reuseNode true
                }
            }
            steps {
                script {
                    sh '''
                        echo "Building Docker image with Kaniko..."
                        echo "${GCP_SERVICE_ACCOUNT_KEY}" | base64 -d > /kaniko/.docker/config.json
                        
                        /kaniko/executor \
                          --dockerfile=Dockerfile \
                          --context=. \
                          --destination=${FULL_IMAGE_NAME} \
                          --destination=${LATEST_IMAGE_NAME} \
                          --cache=true \
                          --cache-ttl=24h
                        
                        echo "Docker image built and pushed successfully with Kaniko!"
                    '''
                }
            }
        }
        
        // Rest of the stages remain the same, but remove the separate Push stage since Kaniko pushes directly
        
        stage('Update Kubernetes Manifests') {
            steps {
                script {
                    sh '''
                        echo "Updating Kubernetes deployment manifest..."
                        sed -i "s|image:.*ace-est-fitness-and-gym.*|image: ${FULL_IMAGE_NAME}|g" infrastructure/k8s/manifest_files/app/deployment.yaml
                        
                        echo "Updated deployment.yaml:"
                        cat infrastructure/k8s/manifest_files/app/deployment.yaml
                    '''
                }
            }
        }
        
        stage('Deploy to Kubernetes') {
            agent {
                docker {
                    image 'google/cloud-sdk:alpine'
                    args '-v ${WORKSPACE}:${WORKSPACE} -w ${WORKSPACE} --entrypoint=""'
                    reuseNode true
                }
            }
            steps {
                script {
                    sh '''
                        echo "Authenticating with GCP..."
                        echo "${GCP_SERVICE_ACCOUNT_KEY}" | base64 -d > gcp-key.json
                        gcloud auth activate-service-account --key-file=gcp-key.json
                        gcloud config set project ${GCP_PROJECT_ID}
                        
                        # Get GKE credentials
                        gcloud container clusters get-credentials ${GKE_CLUSTER_NAME} --region=${GCP_REGION} --project=${GCP_PROJECT_ID}
                        
                        echo "Deploying to Kubernetes cluster..."
                        
                        # Create namespace if it doesn't exist
                        kubectl create namespace ${K8S_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
                        
                        # Apply all Kubernetes manifests
                        kubectl apply -f infrastructure/k8s/manifest_files/app/ -n ${K8S_NAMESPACE}
                        
                        # Wait for deployment to be ready
                        kubectl rollout status deployment/ace-fitness-app -n ${K8S_NAMESPACE} --timeout=300s
                        
                        # Get deployment status
                        kubectl get deployments -n ${K8S_NAMESPACE}
                        kubectl get services -n ${K8S_NAMESPACE}
                        kubectl get pods -n ${K8S_NAMESPACE}
                        
                        rm -f gcp-key.json
                    '''
                }
            }
        }
    }
    
    post {
        always {
            cleanWs()
            archiveArtifacts artifacts: 'coverage.xml,htmlcov/**', allowEmptyArchive: true
        }
        success {
            script {
                echo "‚úÖ Pipeline succeeded!"
                echo "üöÄ Application deployed successfully to Kubernetes!"
                echo "üìä Build Number: ${BUILD_NUMBER}"
                echo "üè∑Ô∏è  Version: ${env.VERSION ?: 'N/A'}"
                echo "üê≥ Docker Image: ${env.FULL_IMAGE_NAME ?: 'N/A'}"
            }
        }
        failure {
            script {
                echo "‚ùå Pipeline failed!"
                echo "üîç Check the logs above for error details"
                echo "üí° Common issues: Docker build failure, K8s deployment timeout, authentication issues"
            }
        }
        unstable {
            echo "‚ö†Ô∏è  Pipeline completed with warnings!"
        }
    }
}